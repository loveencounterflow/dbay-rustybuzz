{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'DBAY-RUSTYBUZZ'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPATH                      = require 'path'\ntypes                     = require './types'\n{ isa\n  type_of\n  validate\n  validate_list_of }      = types.export()\nSQL                       = String.raw\nguy                       = require 'guy'\nhome                      = PATH.resolve PATH.join __dirname, '..'\n# data_path                 = PATH.join home, 'data'\n\n\n#===========================================================================================================\nclass @Drb\n\n  #---------------------------------------------------------------------------------------------------------\n  @C: guy.lft.freeze\n    # replacement:  'â–ˆ'\n    defaults:\n      #.....................................................................................................\n      constructor_cfg:\n        db:               null\n        prefix:           'drb_'\n        schema:           'drb'\n        # path:             PATH.join home,      'cmudict.sqlite'\n        # paths:\n        #   cmu:            PATH.join data_path, 'cmudict-0.7b'\n        #   beep:           PATH.join data_path, 'beep/beep-1.0'\n        #   bf_expansions:  BRITFONE.expansions\n        #   bf_main:        BRITFONE.main\n        #   bf_symbols:     BRITFONE.symbols\n        #   spellings:      PATH.join data_path, 'beep/case.txt'\n        #   abipa:          PATH.join data_path, 'arpabet-to-ipa.tsv'\n        #   xsipa:          PATH.join data_path, 'xsampa-to-ipa.tsv'\n        # create:           false\n        # max_entry_count:  Infinity\n\n  #---------------------------------------------------------------------------------------------------------\n  @cast_constructor_cfg: ( me, cfg = null ) ->\n    clasz           = me.constructor\n    R               = cfg ? me.cfg\n    # #.......................................................................................................\n    # if R.path?\n    #   R.temporary  ?= false\n    #   R.path        = PATH.resolve R.path\n    # else\n    #   R.temporary  ?= true\n    #   filename        = me._get_random_filename()\n    #   R.path        = PATH.resolve PATH.join clasz.C.autolocation, filename\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  @declare_types: ( me ) ->\n    ### called from constructor via `guy.cfg.configure_with_types()` ###\n    me.cfg        = @cast_constructor_cfg me\n    me.types.validate.constructor_cfg me.cfg\n    { db, }       = guy.obj.pluck_with_fallback me.cfg, null, 'db'\n    me.cfg        = guy.lft.freeze guy.obj.omit_nullish me.cfg\n    guy.props.def me, 'db',     { enumerable: false, value: db, }\n    guy.props.def me, 'cache',  { enumerable: false, value: {}, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( cfg ) ->\n    guy.cfg.configure_with_types @, cfg, types\n    @_compile_sql()\n    @_create_sql_functions()\n    @_open_drb_db()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  _create_db_structure: ->\n    { prefix\n      schema } = @cfg\n    #@db.execute SQL\"\"\"\n    #  drop index if exists #{schema}.entries_word_idx;\n    #  drop index if exists #{schema}.entries_ipa_idx;\n    #  drop table if exists #{schema}.trlits;\n    #  drop table if exists #{schema}.trlit_nicks;\n    #  drop table if exists #{schema}.abs_phones;\n    #  drop table if exists #{schema}.entries;\n    #  drop table if exists #{schema}.source_nicks;\n    #  -- ...................................................................................................\n    #  vacuum #{schema};\n    #  -- ...................................................................................................\n    #  create table #{schema}.entries (\n    #      id        integer not null primary key,\n    #      word      text    not null,\n    #      source    text    not null references source_nicks ( nick ),\n    #      nr        integer not null default 1,\n    #      ipa       text    not null,\n    #      ipa_raw   text    not null );\n    #  create index #{schema}.entries_word_idx on entries ( word );\n    #  create index #{schema}.entries_ipa_idx  on entries ( ipa );\n    #  -- ...................................................................................................\n    #  create table #{schema}.trlits ( -- trlits: transliterations\n    #      ipa         text    not null,\n    #      nick        text    not null references trlit_nicks ( nick ),\n    #      trlit       text    not null,\n    #      example     text,\n    #    primary key ( ipa, nick ) );\n    #  create table #{schema}.trlit_nicks (\n    #      nick        text    not null,\n    #      name        text    not null,\n    #      comment     text,\n    #    primary key ( nick ) );\n    #  create table #{schema}.source_nicks (\n    #      nick        text    not null,\n    #      name        text    not null,\n    #      comment     text,\n    #    primary key ( nick ) );\n    #  \"\"\"\n    #  # -- -- ...................................................................................................\n    #  # -- create view #{schema}.abs_phones as select\n    #  # --     r1.word   as word,\n    #  # --     r2.lnr    as lnr,\n    #  # --     r2.rnr    as rnr,\n    #  # --     r2.part   as abs1_phone\n    #  # --   from\n    #  # --     entries                           as r1,\n    #  # --     std_str_split_re( r1.abs1, '\\s' ) as r2;\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_sql: ->\n    { prefix\n      schema }  = @cfg\n    sql         = {}\n    #  get_db_object_count:  SQL\"select count(*) as count from #{schema}.sqlite_schema;\"\n    #  truncate_entries:     SQL\"delete from #{schema}.entries where source = $source;\"\n    #  insert_entry: SQL\"\"\"\n    #    insert into #{schema}.entries ( word, source, nr, ipa_raw, ipa )\n    #      values ( $word, $source, $nr, $ipa_raw, $ipa );\"\"\"\n    #  insert_trlit: SQL\"\"\"\n    #    insert into #{schema}.trlits ( ipa, nick, trlit, example )\n    #      values ( $ipa, $nick, $trlit, $example );\"\"\"\n    #  upsert_source_nick: SQL\"\"\"\n    #    insert into #{schema}.source_nicks ( nick, name, comment )\n    #      values ( $nick, $name, $comment )\n    #      on conflict ( nick ) do update set\n    #        name = excluded.name, comment = excluded.comment;\"\"\"\n    #  upsert_trlit_nick: SQL\"\"\"\n    #    insert into #{schema}.trlit_nicks ( nick, name, comment )\n    #      values ( $nick, $name, $comment )\n    #      on conflict ( nick ) do update set\n    #        name = excluded.name, comment = excluded.comment;\"\"\"\n    #  delete_arpabet_trlits: SQL\"\"\"\n    #    delete from #{schema}.trlits\n    #      where nick in ( 'ab1', 'ab2' );\n    #    \"\"\"\n    #  # insert_abs_phones: SQL\"\"\"\n    #  #   insert into #{schema}.abs_phones ( word, lnr, rnr, abs0_phone, abs1_phone, stress )\n    #  #     values ( $word, $lnr, $rnr, $abs0_phone, $abs1_phone, $stress );\"\"\"\n    guy.props.def @, 'sql', { enumerable: false, value: sql, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _create_sql_functions: ->\n    { prefix\n      schema } = @cfg\n    # #-------------------------------------------------------------------------------------------------------\n    # @db.create_function\n    #   name:           prefix + 'ipa_from_abs1'\n    #   deterministic:  true\n    #   varargs:        false\n    #   call:           ( abs1 ) => @ipa_from_abs1( abs1 )\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  # _get_db_object_count:   -> @db.single_value @sql.get_db_object_count\n  # _truncate_entries:      ( source ) -> @db @sql.truncate_entries, { source, }\n  # _delete_arpabet_trlits: -> @db @sql.delete_arpabet_trlits\n\n  #---------------------------------------------------------------------------------------------------------\n  _open_drb_db: ->\n    @db.open @cfg\n    if @cfg.create or ( @_get_db_object_count() is 0 )\n      @_create_db_structure()\n      @_populate_db()\n    else\n      null\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _populate_db: ->\n    return null\n\n  # #---------------------------------------------------------------------------------------------------------\n  # _populate_cmu_entries: ->\n  #   count         = 0\n  #   insert_entry  = @db.prepare @sql.insert_entry\n  #   source        = 'cmu'\n  #   @_truncate_entries source\n  #   @db @sql.upsert_source_nick, { nick: source, name: \"CMUdict\", comment: \"v0.7b\", }\n  #   @db =>\n  #     for line from guy.fs.walk_lines @cfg.paths.cmu\n  #       continue if line.startsWith ';;;'\n  #       line                  = line.trimEnd()\n  #       [ word, ab, ]         = line.split '\\x20\\x20'\n  #       word                  = word.trim()\n  #       if ( not word? ) or ( word.length is 0 ) or ( not ab? ) or ( ab.length is 0 )\n  #         warn '^4443^', count, ( rpr line )\n  #         continue\n  #       #...................................................................................................\n  #       count++\n  #       if count > @cfg.max_entry_count\n  #         warn '^dbay-cmudict/main@1^', \"shortcutting at #{@cfg.max_entry_count} entries\"\n  #         break\n  #       { word\n  #         nr    } = @_get_bracketed_nr word\n  #       word      = word.toLowerCase()\n  #       word      = @cache.spellings[ word ] ? word ### replace LC variant with correct upper/lower case where found ###\n  #       ipa_raw   = @ipa_raw_from_arpabet2  ab\n  #       ipa       = @ipa_from_cmu_ipa_raw       ipa_raw\n  #       insert_entry.run { word, source, nr, ipa_raw, ipa, }\n  #     return null\n  #   return null\n\n  # #---------------------------------------------------------------------------------------------------------\n  # _cache_spellings: ->\n  #   cache = ( @cache.spellings ?= {} )\n  #   count = 0\n  #   for line from guy.fs.walk_lines @cfg.paths.spellings\n  #     continue if line.startsWith '#'\n  #     line = line.trim()\n  #     continue if line.length is 0\n  #     continue unless ( match = line.match /(?<lc>\\S+)\\s+(?<spelling>.*)$/ )?\n  #     #.....................................................................................................\n  #     count++\n  #     if count > @cfg.max_entry_count\n  #       warn '^dbay-cmudict/main@3^', \"shortcutting at #{@cfg.max_entry_count} entries\"\n  #       break\n  #     #.....................................................................................................\n  #     { lc,\n  #       spelling, } = match.groups\n  #     lc            = lc.toLowerCase()\n  #     spelling      = spelling.trimEnd()\n  #     cache[ lc ]   = spelling\n  #   return null\n\n\n"
  ]
}